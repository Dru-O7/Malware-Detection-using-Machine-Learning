import pefile
import hashlib
import numpy as np

def calculate_md5(file_path):
    try:
        # Open the file in binary mode
        with open(file_path, "rb") as file:
            # Create an MD5 hash object
            md5_hash = hashlib.md5()

            # Read the file in chunks to conserve memory for large files
            while True:
                data = file.read(4096)  # Read 4 KB at a time (adjust as needed)
                if not data:
                    break
                md5_hash.update(data)

            # Calculate the MD5 hash
            md5 = md5_hash.hexdigest()

            return md5
    except Exception as e:
        print(f"An error occurred: {str(e)}")
        return None

def extract_pe_features(file_path):
    try:
        pe = pefile.PE(file_path)

        # Extract the desired features
        feature_values = []

        # Append feature values to the list
        feature_values.append(file_path)  # Name remains as a string
        feature_values.append(calculate_md5(file_path))  # MD5 remains as a string

        # Convert and append numeric features
        feature_values += [
            float(pe.FILE_HEADER.Machine),
            float(pe.FILE_HEADER.SizeOfOptionalHeader),
            float(pe.FILE_HEADER.Characteristics),
            float(pe.OPTIONAL_HEADER.MajorLinkerVersion),
            float(pe.OPTIONAL_HEADER.MinorLinkerVersion),
            float(pe.OPTIONAL_HEADER.SizeOfCode),
            float(pe.OPTIONAL_HEADER.SizeOfInitializedData),
            float(pe.OPTIONAL_HEADER.SizeOfUninitializedData),
            float(pe.OPTIONAL_HEADER.AddressOfEntryPoint),
            float(pe.OPTIONAL_HEADER.BaseOfCode),
            float(pe.OPTIONAL_HEADER.BaseOfData),
            float(pe.OPTIONAL_HEADER.ImageBase),
            float(pe.OPTIONAL_HEADER.SectionAlignment),
            float(pe.OPTIONAL_HEADER.FileAlignment),
            float(pe.OPTIONAL_HEADER.MajorOperatingSystemVersion),
            float(pe.OPTIONAL_HEADER.MinorOperatingSystemVersion),
            float(pe.OPTIONAL_HEADER.MajorImageVersion),
            float(pe.OPTIONAL_HEADER.MinorImageVersion),
            float(pe.OPTIONAL_HEADER.MajorSubsystemVersion),
            float(pe.OPTIONAL_HEADER.MinorSubsystemVersion),
            float(pe.OPTIONAL_HEADER.SizeOfImage),
            float(pe.OPTIONAL_HEADER.SizeOfHeaders),
            float(pe.OPTIONAL_HEADER.CheckSum),
            float(pe.OPTIONAL_HEADER.Subsystem),
            float(pe.OPTIONAL_HEADER.DllCharacteristics),
            float(pe.OPTIONAL_HEADER.SizeOfStackReserve),
            float(pe.OPTIONAL_HEADER.SizeOfStackCommit),
            float(pe.OPTIONAL_HEADER.SizeOfHeapReserve),
            float(pe.OPTIONAL_HEADER.SizeOfHeapCommit),
            float(pe.OPTIONAL_HEADER.LoaderFlags),
            float(pe.OPTIONAL_HEADER.NumberOfRvaAndSizes),
            float(len(pe.sections))
        ]

        sections_entropy = [float(section.get_entropy()) for section in pe.sections]
        feature_values.append(float(sum(sections_entropy)) / float(len(sections_entropy)))
        feature_values.append(float(min(sections_entropy)))
        feature_values.append(float(max(sections_entropy)))

        sections_raw_size = [float(section.SizeOfRawData) for section in pe.sections]
        feature_values.append(float(sum(sections_raw_size)) / float(len(sections_raw_size)))
        feature_values.append(float(min(sections_raw_size)))
        feature_values.append(float(max(sections_raw_size)))

        sections_virtual_size = [float(section.Misc_VirtualSize) for section in pe.sections]
        feature_values.append(float(sum(sections_virtual_size)) / float(len(sections_virtual_size)))
        feature_values.append(float(min(sections_virtual_size)))
        feature_values.append(float(max(sections_virtual_size)))
        feature_values.append(1.0)  # Append 1.0 as a float

        return feature_values

    except Exception as e:
        print(f"An error occurred: {str(e)}")
        return None

if __name__ == "__main":
    file_path = "835e47i5.exe"  # Replace with the actual file path
    pe_feature_values = extract_pe_features(file_path)

    if pe_feature_values:
        # Convert the list of feature values to a NumPy array
        pe_feature_values_array = np.array(pe_feature_values)

        print(pe_feature_values_array)
